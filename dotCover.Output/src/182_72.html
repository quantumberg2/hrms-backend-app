<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\USER\source\HRMS\hrms-backend-app\HRMS Application\Controllers\LeaveTrackingController.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using HRMS_Application.Models;
using HRMS_Application.BusinessLogic.Interface;
using Microsoft.AspNetCore.Mvc;
using System;
using System.Threading.Tasks;
using System.IdentityModel.Tokens.Jwt;
using HRMS_Application.Authorization;
using HRMS_Application.DTO;

namespace HRMS_Application.Controllers
{
    [ApiController]
    [Route(&quot;api/[controller]&quot;)]
    public class LeaveTrackingController : ControllerBase
    {
        private readonly ILeaveTracking _leaveTracking;
        private readonly ILogger&lt;LeaveTrackingController&gt; _logger;

        public LeaveTrackingController(ILeaveTracking leaveTracking, ILogger&lt;LeaveTrackingController&gt; logger)
        {
            _leaveTracking = leaveTracking;
            _logger = logger;
        }

        [HttpGet]
        public async Task&lt;IActionResult&gt; GetAll()
        {
            _logger.LogInformation(&quot;Get all leaves method started&quot;);
            var leaveTrackings = await _leaveTracking.GetAllAsync();
            return Ok(leaveTrackings);
        }

        [HttpGet(&quot;{id}&quot;)]
        public async Task&lt;IActionResult&gt; GetById(int id)
        {
            _logger.LogInformation(&quot;Get leaves by Id method started&quot;);

            var leaveTracking = await _leaveTracking.GetByIdAsync(id);
            if (leaveTracking == null)
            {
                return NotFound();
            }
            return Ok(leaveTracking);
        }

        [HttpPost]
        [Authorize(new[] { &quot;Admin&quot;, &quot;User&quot; })]
        public async Task&lt;IActionResult&gt; CreateLeaveTracking([FromBody] LeaveTrackingDTO leaveTrackingDto)
        {
            _logger.LogInformation(&quot;Apply leave method started&quot;);

            try
            {
                // Extract the token from the Authorization header
                var token = HttpContext.Request.Headers[&quot;Authorization&quot;].ToString().Replace(&quot;Bearer &quot;, &quot;&quot;).Trim();

                // Check if the token is present
                if (string.IsNullOrEmpty(token))
                {
                    return Unauthorized(&quot;Authorization header is missing or token is empty.&quot;);
                }

                // Decode the JWT token to extract claims
                var handler = new JwtSecurityTokenHandler();
                if (!handler.CanReadToken(token))
                {
                    return Unauthorized(&quot;Invalid token format.&quot;);
                }

                var jwtToken = handler.ReadJwtToken(token);
                var empCredentialIdClaim = jwtToken.Claims.FirstOrDefault(claim =&gt; claim.Type == &quot;UserId&quot;);

                if (empCredentialIdClaim == null)
                {
                    return Unauthorized(&quot;Employee credential ID not found in token.&quot;);
                }

                // Parse the empCredentialId from the claim
                int empCredentialId = int.Parse(empCredentialIdClaim.Value);

                // Map the DTO to the entity model
                var leaveTracking = new LeaveTracking
                {
                    LeaveTypeId = leaveTrackingDto.LeaveTypeId,
                    Startdate = leaveTrackingDto.StartDate,
                    Enddate = leaveTrackingDto.EndDate,
                    ReasonForLeave = leaveTrackingDto.ReasonForLeave,
                    EmpCredentialId = empCredentialId,
                    AppliedDate = leaveTrackingDto.Applied,
                    Status = &quot;Pending&quot;,
                    Files = leaveTrackingDto.Files,
                    Session = leaveTrackingDto.Session,
                    Contact = leaveTrackingDto.Contact,
                    IsActive = 1,
                    // Map other necessary fields here
                };

                // Call the service to create the leave tracking record
                var result = await _leaveTracking.CreateAsync(leaveTracking, empCredentialId);

                return Ok(result);
            }
            catch (Exception ex)
            {
                return BadRequest($&quot;An error occurred: {ex.Message}&quot;);
            }
        }

        [HttpPost(&quot;Apply_Behalf&quot;)]
        [Authorize(new[] { &quot;Admin&quot; })]
        public async Task&lt;IActionResult&gt; ApllyLeaveBehalf([FromBody] LeaveTrackingDTO leaveTrackingDto, int empCredentialId)
        {
            _logger.LogInformation(&quot;Apply leave method started&quot;);

            try
            {
               

                // Map the DTO to the entity model
                var leaveTracking = new LeaveTracking
                {
                    LeaveTypeId = leaveTrackingDto.LeaveTypeId,
                    Startdate = leaveTrackingDto.StartDate,
                    Enddate = leaveTrackingDto.EndDate,
                    ReasonForLeave = leaveTrackingDto.ReasonForLeave,
                    EmpCredentialId = empCredentialId,
                    AppliedDate = leaveTrackingDto.Applied,
                    Status = &quot;Approved&quot;,
                    Files = leaveTrackingDto.Files,
                    Session = leaveTrackingDto.Session,
                    Contact = leaveTrackingDto.Contact,
                    IsActive = 1,
                    // Map other necessary fields here
                };

                // Call the service to create the leave tracking record
                var result = await _leaveTracking.ApllyLeaveBehalf(leaveTracking, empCredentialId);

                return Ok(result);
            }
            catch (Exception ex)
            {
                return BadRequest($&quot;An error occurred: {ex.Message}&quot;);
            }
        }

        [HttpPut(&quot;{id}&quot;)]
        public async Task&lt;IActionResult&gt; Update(int id, [FromBody] LeaveTracking leaveTracking)
        {
            _logger.LogInformation(&quot;Update leaves method started&quot;);

            if (id != leaveTracking.Id)
            {
                return BadRequest(&quot;ID mismatch&quot;);
            }

            if (!ModelState.IsValid)  
            {
                return BadRequest(ModelState);
            }

            var updatedLeaveTracking = await _leaveTracking.UpdateAsync(leaveTracking);
            if (updatedLeaveTracking == null)
            {
                return NotFound();
            }

            return Ok(updatedLeaveTracking);
        }

        [HttpPut(&quot;statusUpdate&quot;)]
        [Authorize(new[] { &quot;Admin&quot; })]

        public async Task&lt;IActionResult&gt; UpdateLeaveAsync(int id, string newStatus)
        {
            _logger.LogInformation(&quot;update leave status method started&quot;);

            var status =await _leaveTracking.UpdateLeaveAsync(id,newStatus);
            return Ok(status);
        }

        [HttpDelete(&quot;{id}&quot;)]
        public async Task&lt;IActionResult&gt; Delete(int id)
        {
            _logger.LogInformation(&quot;delete leaves method started&quot;);

            var result = await _leaveTracking.DeleteAsync(id);
            if (!result)
            {
                return NotFound();
            }

            return NoContent();
        }
        [HttpGet(&quot;leaves/{status}&quot;)]
        public async Task&lt;ActionResult&lt;List&lt;LeaveApprovalDTO&gt;&gt;&gt; GetLeavesByStatus(string status)
        {
            _logger.LogInformation(&quot;Get leaves by status method started&quot;);

            var leaves = await _leaveTracking.GetLeavesByStatusAsync(status);

            if (leaves == null || !leaves.Any())
            {
                return NotFound(&quot;No leave records found with the given status.&quot;);
            }

            return Ok(leaves);
        }

        [HttpGet(&quot;summary&quot;)]
        [Authorize(new[] { &quot;Admin&quot;, &quot;User&quot; })]

        public async Task&lt;IActionResult&gt; GetLeaveSummary()
        {
            _logger.LogInformation(&quot;Get leave summary method started&quot;);

            try
            {
                // Extract employee credential ID from the JWT token
                var token = HttpContext.Request.Headers[&quot;Authorization&quot;].ToString().Replace(&quot;Bearer &quot;, &quot;&quot;);
                var jwtToken = new JwtSecurityTokenHandler().ReadJwtToken(token);
                var employeeCredentialId = int.Parse(jwtToken.Claims.First(c =&gt; c.Type == &quot;UserId&quot;).Value); // Replace &#39;employee_id&#39; with the actual claim name


                var leaveSummary = await _leaveTracking.GetEmployeeLeaveSummaryAsync(employeeCredentialId);

                return Ok(leaveSummary);
            }
            catch (Exception ex)
            {
                return BadRequest(new { message = ex.Message });
            }
        }

        [HttpPut(&quot;SoftDelete&quot;)]
        [Authorize(new[] { &quot;Admin&quot; })]

        public bool SoftDelete(int id, short isActive)
        {
            _logger.LogInformation(&quot;Soft update Leave tracking method started&quot;);
            var res = _leaveTracking.SoftDelete(id, isActive);
            return res;

        }
        [HttpGet(&quot;pending-leaves&quot;)]
        public IActionResult GetPendingLeaves()
        {
            _logger.LogInformation(&quot;Apply leave method started&quot;);

            try
            {
                // Extract the token from the Authorization header
                var token = HttpContext.Request.Headers[&quot;Authorization&quot;].ToString().Replace(&quot;Bearer &quot;, &quot;&quot;).Trim();

                // Check if the token is present
                if (string.IsNullOrEmpty(token))
                {
                    return Unauthorized(&quot;Authorization header is missing or token is empty.&quot;);
                }

                // Decode the JWT token to extract claims
                var handler = new JwtSecurityTokenHandler();
                if (!handler.CanReadToken(token))
                {
                    return Unauthorized(&quot;Invalid token format.&quot;);
                }

                var jwtToken = handler.ReadJwtToken(token);
                // Extract the &quot;UserId&quot; claim from the token. 
                // Ensure this claim matches what you expect (e.g., &quot;UserId&quot; should contain the employeeCredentialId).
                var employeeCredentialIdClaim = jwtToken.Claims.FirstOrDefault(claim =&gt; claim.Type == &quot;UserId&quot;)?.Value;

                if (string.IsNullOrEmpty(employeeCredentialIdClaim) || !int.TryParse(employeeCredentialIdClaim, out var employeeCredentialId))
                {
                    return Unauthorized(&quot;Employee credential ID not found or invalid in the token.&quot;);
                }

                // Call the service to get pending leaves using the extracted employeeCredentialId
                var pendingLeaves = _leaveTracking.GetPendingLeaves(employeeCredentialId);

                return Ok(pendingLeaves);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, &quot;An error occurred while fetching pending leaves&quot;);
                // Handle any errors
                return StatusCode(500, &quot;Internal server error: &quot; + ex.Message);
            }
        }
        [HttpGet(&quot;History-leaves&quot;)]
        public IActionResult Historyleaves()
        {
            _logger.LogInformation(&quot;History leave method started&quot;);

            try
            {
                // Extract the token from the Authorization header
                var token = HttpContext.Request.Headers[&quot;Authorization&quot;].ToString().Replace(&quot;Bearer &quot;, &quot;&quot;).Trim();

                // Check if the token is present
                if (string.IsNullOrEmpty(token))
                {
                    return Unauthorized(&quot;Authorization header is missing or token is empty.&quot;);
                }

                // Decode the JWT token to extract claims
                var handler = new JwtSecurityTokenHandler();
                if (!handler.CanReadToken(token))
                {
                    return Unauthorized(&quot;Invalid token format.&quot;);
                }

                var jwtToken = handler.ReadJwtToken(token);
                // Extract the &quot;UserId&quot; claim from the token. 
                // Ensure this claim matches what you expect (e.g., &quot;UserId&quot; should contain the employeeCredentialId).
                var employeeCredentialIdClaim = jwtToken.Claims.FirstOrDefault(claim =&gt; claim.Type == &quot;UserId&quot;)?.Value;

                if (string.IsNullOrEmpty(employeeCredentialIdClaim) || !int.TryParse(employeeCredentialIdClaim, out var employeeCredentialId))
                {
                    return Unauthorized(&quot;Employee credential ID not found or invalid in the token.&quot;);
                }

                // Call the service to get pending leaves using the extracted employeeCredentialId
                var pendingLeaves = _leaveTracking.GetHistoryLeaves(employeeCredentialId);

                return Ok(pendingLeaves);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, &quot;An error occurred while fetching History leaves&quot;);
                // Handle any errors
                return StatusCode(500, &quot;Internal server error: &quot; + ex.Message);
            }
        }

        [HttpPut(&quot;Leave-Withdrawn&quot;)]
        [Authorize(new[] { &quot;Admin&quot;, &quot;User&quot; })]
        public async Task&lt;IActionResult&gt; UpdateLeaveStatus(int id, string newStatus)
        {

            try
            {
                // Extract the token from the Authorization header
                var token = HttpContext.Request.Headers[&quot;Authorization&quot;].ToString().Replace(&quot;Bearer &quot;, &quot;&quot;).Trim();

                // Check if the token is present
                if (string.IsNullOrEmpty(token))
                {
                    return Unauthorized(&quot;Authorization header is missing or token is empty.&quot;);
                }

                // Decode the JWT token to extract claims
                var handler = new JwtSecurityTokenHandler();
                if (!handler.CanReadToken(token))
                {
                    return Unauthorized(&quot;Invalid token format.&quot;);
                }

                var jwtToken = handler.ReadJwtToken(token);
                // Extract the &quot;UserId&quot; claim from the token. 
                // Ensure this claim matches what you expect (e.g., &quot;UserId&quot; should contain the employeeCredentialId).
                var employeeCredentialIdClaim = jwtToken.Claims.FirstOrDefault(claim =&gt; claim.Type == &quot;UserId&quot;)?.Value;

                if (string.IsNullOrEmpty(employeeCredentialIdClaim) || !int.TryParse(employeeCredentialIdClaim, out var employeeCredentialId))
                {
                    return Unauthorized(&quot;Employee credential ID not found or invalid in the token.&quot;);
                }


                // Update the leave status
                var leaveTracking = await _leaveTracking.UpdateLeaveAsyncchanges(employeeCredentialId, id, newStatus);

                if (leaveTracking == null)
                {
                    return NotFound(&quot;Leave record not found.&quot;);
                }

                return Ok(leaveTracking);
            }
            catch (Exception ex)
            {
                return StatusCode(500, $&quot;Internal server error: {ex.Message}&quot;);
            }
        
                  
        }


    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[19,9,19,110,1],[20,9,20,10,1],[21,13,21,44,1],[22,13,22,30,1],[23,9,23,10,1],[27,9,27,10,1],[28,13,28,69,1],[29,13,29,69,1],[30,13,30,39,1],[31,9,31,10,1],[35,9,35,10,1],[36,13,36,71,1],[38,13,38,71,1],[39,13,39,39,1],[40,13,40,14,0],[41,17,41,35,0],[43,13,43,38,1],[44,9,44,10,1],[49,9,49,10,1],[50,13,50,66,1],[53,13,53,14,1],[55,17,55,115,1],[58,17,58,49,0],[59,17,59,18,0],[60,21,60,95,0],[64,17,64,61,0],[65,17,65,50,0],[66,17,66,18,0],[67,21,67,66,0],[70,17,70,60,0],[71,17,71,84,0],[71,84,71,106,0],[71,106,71,108,0],[73,17,73,50,0],[74,17,74,18,0],[75,21,75,87,0],[79,17,79,77,0],[82,17,96,19,0],[99,17,99,95,0],[101,17,101,35,0],[103,13,103,33,1],[104,13,104,14,1],[105,17,105,71,1],[107,9,107,10,1],[112,9,112,10,1],[113,13,113,66,1],[116,13,116,14,1],[120,17,134,19,1],[137,17,137,100,1],[139,17,139,35,1],[141,13,141,33,0],[142,13,142,14,0],[143,17,143,71,0],[145,9,145,10,1],[149,9,149,10,1],[150,13,150,68,1],[152,13,152,40,1],[153,13,153,14,1],[154,17,154,50,1],[157,13,157,37,0],[158,13,158,14,0],[159,17,159,47,0],[162,13,162,88,0],[163,13,163,46,0],[164,13,164,14,0],[165,17,165,35,0],[168,13,168,45,0],[169,9,169,10,1],[175,9,175,10,1],[176,13,176,74,1],[178,13,178,77,1],[179,13,179,31,1],[180,9,180,10,1],[184,9,184,10,1],[185,13,185,68,1],[187,13,187,63,1],[188,13,188,25,1],[189,13,189,14,1],[190,17,190,35,1],[193,13,193,32,0],[194,9,194,10,1],[197,9,197,10,1],[198,13,198,75,1],[200,13,200,78,1],[202,13,202,49,1],[203,13,203,14,1],[204,17,204,82,1],[207,13,207,31,0],[208,9,208,10,1],[214,9,214,10,0],[215,13,215,72,0],[218,13,218,14,0],[220,17,220,108,0],[221,17,221,82,0],[222,17,222,81,0],[222,81,222,99,0],[222,99,222,108,0],[225,17,225,108,0],[227,17,227,41,0],[229,13,229,33,0],[230,13,230,14,0],[231,17,231,65,0],[233,9,233,10,0],[239,9,239,10,1],[240,13,240,81,1],[241,13,241,63,1],[242,13,242,24,1],[244,9,244,10,1],[247,9,247,10,1],[248,13,248,66,1],[251,13,251,14,1],[253,17,253,115,1],[256,17,256,49,0],[257,17,257,18,0],[258,21,258,95,0],[262,17,262,61,0],[263,17,263,50,0],[264,17,264,18,0],[265,21,265,66,0],[268,17,268,60,0],[271,17,271,89,0],[271,89,271,111,0],[271,111,271,120,0],[273,17,273,143,0],[274,17,274,18,0],[275,21,275,102,0],[279,17,279,91,0],[281,17,281,42,0],[283,13,283,33,1],[284,13,284,14,1],[285,17,285,89,1],[287,17,287,80,1],[289,9,289,10,1],[292,9,292,10,1],[293,13,293,68,1],[296,13,296,14,1],[298,17,298,115,1],[301,17,301,49,0],[302,17,302,18,0],[303,21,303,95,0],[307,17,307,61,0],[308,17,308,50,0],[309,17,309,18,0],[310,21,310,66,0],[313,17,313,60,0],[316,17,316,89,0],[316,89,316,111,0],[316,111,316,120,0],[318,17,318,143,0],[319,17,319,18,0],[320,21,320,102,0],[324,17,324,91,0],[326,17,326,42,0],[328,13,328,33,1],[329,13,329,14,1],[330,17,330,89,1],[332,17,332,80,1],[334,9,334,10,1],[339,9,339,10,1],[342,13,342,14,1],[344,17,344,115,1],[347,17,347,49,0],[348,17,348,18,0],[349,21,349,95,0],[353,17,353,61,0],[354,17,354,50,0],[355,17,355,18,0],[356,21,356,66,0],[359,17,359,60,0],[362,17,362,89,0],[362,89,362,111,0],[362,111,362,120,0],[364,17,364,143,0],[365,17,365,18,0],[366,21,366,102,0],[371,17,371,119,0],[373,17,373,43,0],[374,17,374,18,0],[375,21,375,64,0],[378,17,378,42,0],[380,13,380,33,1],[381,13,381,14,1],[382,17,382,80,1],[386,9,386,10,1]]);
    </script>
  </body>
</html>